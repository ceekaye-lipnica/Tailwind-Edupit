"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generatePluginCss = exports.buildPlugin = exports.getSettings = exports.buildConfigFromRecipe = exports.prefixNegativeModifiers = exports.handleName = exports.FLATTEN_CONFIG = void 0;

var _lodash = _interopRequireDefault(require("lodash"));

var _flat = _interopRequireDefault(require("flat"));

var _postcss = _interopRequireDefault(require("postcss"));

var _tailwindcss = _interopRequireDefault(require("tailwindcss"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * CONSTANTS
 */
const FLATTEN_CONFIG = {
  delimiter: '-',
  maxDepth: 2
};
/**
 * handleName()
 *
 * @param {string} className
 * @param {string} base
 */

exports.FLATTEN_CONFIG = FLATTEN_CONFIG;

const handleName = (className, base) => {
  const split = className.split(`${base}-`);
  const prefixedName = `${split[0]}${prefixNegativeModifiers(base, split[1])}`;
  return prefixedName.split('-default').join('');
};

exports.handleName = handleName;

const prefixNegativeModifiers = (base, modifier) => {
  return _lodash.default.startsWith(modifier, '-') ? `-${base}-${modifier.slice(1)}` : `${base}-${modifier}`;
};
/**
 * buildConfig()
 *
 * @param {Object} tailwindConfig
 * @param {Object} coreUtils
 * @param {string} themeKey
 * @param {...string} fallbackKeys
 */


exports.prefixNegativeModifiers = prefixNegativeModifiers;

const buildConfigFromRecipe = (coreUtils, recipe) => {
  const {
    key: [themeKey, ...fallbackKeys],
    property,
    config
  } = recipe;

  const buildFromEntries = ([modifier, value]) => [modifier, {
    [property || themeKey]: value
  }];

  const themeSettings = getSettings(coreUtils.theme, themeKey, fallbackKeys);
  const settings = themeSettings || getSettings(config.theme, themeKey, fallbackKeys);
  const object = Array.isArray(settings) ? _lodash.default.zipObject(settings, settings) : settings;
  const flatObject = themeSettings ? (0, _flat.default)(object, FLATTEN_CONFIG) : object;
  const entries = settings && Object.entries(flatObject).map(buildFromEntries);
  return settings ? _lodash.default.fromPairs(entries) : false;
};
/**
 * getSettings()
 *
 * @param {function|Object} theme
 * @param {string} themeKey
 * @param {string[]} fallbackKeys
 */


exports.buildConfigFromRecipe = buildConfigFromRecipe;

const getSettings = (theme, themeKey, fallbackKeys = []) => {
  const [newThemeKey, ...newFallbackKeys] = fallbackKeys;
  const value = typeof theme === 'function' ? theme(themeKey, false) : theme[themeKey];
  return !_lodash.default.isEmpty(value) && value || fallbackKeys.length && getSettings(theme, newThemeKey, newFallbackKeys) || {};
};
/**
 * buildPlugin()
 *
 * @param {Object} tailwindConfig
 * @param {Object} coreUtils
 * @param {Object} pluginRecipes
 */
// TODO: Rename to denote it ONLY adds utilities


exports.getSettings = getSettings;

const buildPlugin = (coreUtils, tailwindConfig, pluginRecipes) => {
  // TODO: Add support for String recipes?
  const prepareRecipe = recipe => {
    const {
      // TODO: Add support for String keys?
      key,
      // Array
      base = _lodash.default.kebabCase(key[0]),
      property = _lodash.default.kebabCase(key[0]),
      // TODO: Support passing default config using new core API
      config = tailwindConfig // TODO: Support passing addUtilitiesOptions
      // options = { respectPrefix: false, respectImportant: false, variants: [] },

    } = recipe;
    return key ? {
      key,
      base,
      property,
      config
    } : recipe;
  };

  return (Array.isArray(pluginRecipes) ? pluginRecipes : [pluginRecipes]).map(prepareRecipe).forEach(recipe => {
    const {
      key,
      base,
      property,
      config
    } = recipe; // TODO: Support specifying a property Ã  la `tailwindcss-alpha` and `tailwindcss-custom-native`

    const buildFromRecipe = ([index, value]) => [index, buildConfigFromRecipe(coreUtils, recipe)]; // TODO: All this mess is probably not required anymore


    return Object.entries(_lodash.default.fromPairs(Object.entries({
      [base]: key
    }).map(buildFromRecipe))).filter(([modifier, values]) => !_lodash.default.isEmpty(values)).forEach(([modifier, values]) => {
      const {
        addUtilities,
        e,
        variants
      } = coreUtils; // const base = _.kebabCase(modifier).split('-').slice(0, 2).join('-')
      // const variantName = Object.keys(Object.entries(values)[0][1])[0]

      const flatValues = Object.entries((0, _flat.default)({
        [base]: values
      }, FLATTEN_CONFIG)).map(([className, value]) => [`.${e(`${className}`)}`, value]);
      const utilities = (0, _lodash.default)(flatValues).fromPairs().mapKeys((value, key) => handleName(key, base)).value();
      return addUtilities(utilities, {
        // TODO: Should it really default to ['responsive]?
        variants: variants(key[0], ['responsive'])
      });
    });
  });
};
/**
 * generatePluginCss()
 *
 * @param {Object} tailwindConfig
 * @param {Object} testConfig
 */


exports.buildPlugin = buildPlugin;

const generatePluginCss = (tailwindConfig = {}, testConfig = {}) => {
  // TODO: Allow users to specify which version of Tailwind to use?
  // TODO: Allow users to configure what is it that the helper generates aka `@tailwind utilities`
  const customizer = (objValue, srcValue, key) => {
    if (key === 'variants' && _lodash.default.isArray(objValue) && _lodash.default.isEmpty(objValue)) {
      return srcValue;
    }
  };

  const sandboxConfig = {
    theme: {
      screens: {
        sm: '640px'
      }
    },
    corePlugins: false,
    variants: []
  };
  const configs = [tailwindConfig, sandboxConfig, testConfig];
  const postcssPlugins = [(0, _tailwindcss.default)(_lodash.default.mergeWith({}, ...configs, customizer))];
  return (0, _postcss.default)(postcssPlugins).process('@tailwind utilities', {
    from: undefined
  }).then(result => result.css);
};

exports.generatePluginCss = generatePluginCss;